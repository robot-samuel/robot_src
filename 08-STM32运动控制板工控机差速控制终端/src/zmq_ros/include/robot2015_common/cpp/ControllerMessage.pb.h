// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ControllerMessage.proto

#ifndef PROTOBUF_ControllerMessage_2eproto__INCLUDED
#define PROTOBUF_ControllerMessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "ExternSensor.pb.h"
#include "MotecDriverStat.pb.h"
#include "BMSMessage.pb.h"
#include "ErrorMessage.pb.h"
#include "AlarmMessage.pb.h"
#include "UltrasoundMessage.pb.h"
#include "ph3airmsg.pb.h"
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_ControllerMessage_2eproto();
void protobuf_AssignDesc_ControllerMessage_2eproto();
void protobuf_ShutdownFile_ControllerMessage_2eproto();

class ControllerMessage;
class ControllerMessage_Dirver;

// ===================================================================

class ControllerMessage_Dirver : public ::google::protobuf::Message {
 public:
  ControllerMessage_Dirver();
  virtual ~ControllerMessage_Dirver();

  ControllerMessage_Dirver(const ControllerMessage_Dirver& from);

  inline ControllerMessage_Dirver& operator=(const ControllerMessage_Dirver& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerMessage_Dirver& default_instance();

  void Swap(ControllerMessage_Dirver* other);

  // implements Message ----------------------------------------------

  ControllerMessage_Dirver* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControllerMessage_Dirver& from);
  void MergeFrom(const ControllerMessage_Dirver& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 device_status = 1;
  inline bool has_device_status() const;
  inline void clear_device_status();
  static const int kDeviceStatusFieldNumber = 1;
  inline ::google::protobuf::int32 device_status() const;
  inline void set_device_status(::google::protobuf::int32 value);

  // optional int32 device_add = 2;
  inline bool has_device_add() const;
  inline void clear_device_add();
  static const int kDeviceAddFieldNumber = 2;
  inline ::google::protobuf::int32 device_add() const;
  inline void set_device_add(::google::protobuf::int32 value);

  // optional int32 ActVelocity = 3;
  inline bool has_actvelocity() const;
  inline void clear_actvelocity();
  static const int kActVelocityFieldNumber = 3;
  inline ::google::protobuf::int32 actvelocity() const;
  inline void set_actvelocity(::google::protobuf::int32 value);

  // optional int32 SetVelocity = 4;
  inline bool has_setvelocity() const;
  inline void clear_setvelocity();
  static const int kSetVelocityFieldNumber = 4;
  inline ::google::protobuf::int32 setvelocity() const;
  inline void set_setvelocity(::google::protobuf::int32 value);

  // optional float ctrl_dc_Voltage = 5;
  inline bool has_ctrl_dc_voltage() const;
  inline void clear_ctrl_dc_voltage();
  static const int kCtrlDcVoltageFieldNumber = 5;
  inline float ctrl_dc_voltage() const;
  inline void set_ctrl_dc_voltage(float value);

  // optional float CTRL_IPM_TEMPERATURE = 6;
  inline bool has_ctrl_ipm_temperature() const;
  inline void clear_ctrl_ipm_temperature();
  static const int kCTRLIPMTEMPERATUREFieldNumber = 6;
  inline float ctrl_ipm_temperature() const;
  inline void set_ctrl_ipm_temperature(float value);

  // optional int32 ActualPos = 7;
  inline bool has_actualpos() const;
  inline void clear_actualpos();
  static const int kActualPosFieldNumber = 7;
  inline ::google::protobuf::int32 actualpos() const;
  inline void set_actualpos(::google::protobuf::int32 value);

  // optional bool EmergencyInputValue = 8;
  inline bool has_emergencyinputvalue() const;
  inline void clear_emergencyinputvalue();
  static const int kEmergencyInputValueFieldNumber = 8;
  inline bool emergencyinputvalue() const;
  inline void set_emergencyinputvalue(bool value);

  // optional string Error = 9;
  inline bool has_error() const;
  inline void clear_error();
  static const int kErrorFieldNumber = 9;
  inline const ::std::string& error() const;
  inline void set_error(const ::std::string& value);
  inline void set_error(const char* value);
  inline void set_error(const char* value, size_t size);
  inline ::std::string* mutable_error();
  inline ::std::string* release_error();
  inline void set_allocated_error(::std::string* error);

  // optional .MotecDriverStat motec = 10;
  inline bool has_motec() const;
  inline void clear_motec();
  static const int kMotecFieldNumber = 10;
  inline const ::MotecDriverStat& motec() const;
  inline ::MotecDriverStat* mutable_motec();
  inline ::MotecDriverStat* release_motec();
  inline void set_allocated_motec(::MotecDriverStat* motec);

  // optional float ActCurrent = 11;
  inline bool has_actcurrent() const;
  inline void clear_actcurrent();
  static const int kActCurrentFieldNumber = 11;
  inline float actcurrent() const;
  inline void set_actcurrent(float value);

  // @@protoc_insertion_point(class_scope:ControllerMessage.Dirver)
 private:
  inline void set_has_device_status();
  inline void clear_has_device_status();
  inline void set_has_device_add();
  inline void clear_has_device_add();
  inline void set_has_actvelocity();
  inline void clear_has_actvelocity();
  inline void set_has_setvelocity();
  inline void clear_has_setvelocity();
  inline void set_has_ctrl_dc_voltage();
  inline void clear_has_ctrl_dc_voltage();
  inline void set_has_ctrl_ipm_temperature();
  inline void clear_has_ctrl_ipm_temperature();
  inline void set_has_actualpos();
  inline void clear_has_actualpos();
  inline void set_has_emergencyinputvalue();
  inline void clear_has_emergencyinputvalue();
  inline void set_has_error();
  inline void clear_has_error();
  inline void set_has_motec();
  inline void clear_has_motec();
  inline void set_has_actcurrent();
  inline void clear_has_actcurrent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 device_status_;
  ::google::protobuf::int32 device_add_;
  ::google::protobuf::int32 actvelocity_;
  ::google::protobuf::int32 setvelocity_;
  float ctrl_dc_voltage_;
  float ctrl_ipm_temperature_;
  ::google::protobuf::int32 actualpos_;
  bool emergencyinputvalue_;
  ::std::string* error_;
  ::MotecDriverStat* motec_;
  float actcurrent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ControllerMessage_2eproto();
  friend void protobuf_AssignDesc_ControllerMessage_2eproto();
  friend void protobuf_ShutdownFile_ControllerMessage_2eproto();

  void InitAsDefaultInstance();
  static ControllerMessage_Dirver* default_instance_;
};
// -------------------------------------------------------------------

class ControllerMessage : public ::google::protobuf::Message {
 public:
  ControllerMessage();
  virtual ~ControllerMessage();

  ControllerMessage(const ControllerMessage& from);

  inline ControllerMessage& operator=(const ControllerMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ControllerMessage& default_instance();

  void Swap(ControllerMessage* other);

  // implements Message ----------------------------------------------

  ControllerMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ControllerMessage& from);
  void MergeFrom(const ControllerMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ControllerMessage_Dirver Dirver;

  // accessors -------------------------------------------------------

  // optional int32 Stat = 1;
  inline bool has_stat() const;
  inline void clear_stat();
  static const int kStatFieldNumber = 1;
  inline ::google::protobuf::int32 stat() const;
  inline void set_stat(::google::protobuf::int32 value);

  // repeated .ControllerMessage.Dirver DirverMessage = 2;
  inline int dirvermessage_size() const;
  inline void clear_dirvermessage();
  static const int kDirverMessageFieldNumber = 2;
  inline const ::ControllerMessage_Dirver& dirvermessage(int index) const;
  inline ::ControllerMessage_Dirver* mutable_dirvermessage(int index);
  inline ::ControllerMessage_Dirver* add_dirvermessage();
  inline const ::google::protobuf::RepeatedPtrField< ::ControllerMessage_Dirver >&
      dirvermessage() const;
  inline ::google::protobuf::RepeatedPtrField< ::ControllerMessage_Dirver >*
      mutable_dirvermessage();

  // optional .ExternSensor SensorMsg = 3;
  inline bool has_sensormsg() const;
  inline void clear_sensormsg();
  static const int kSensorMsgFieldNumber = 3;
  inline const ::ExternSensor& sensormsg() const;
  inline ::ExternSensor* mutable_sensormsg();
  inline ::ExternSensor* release_sensormsg();
  inline void set_allocated_sensormsg(::ExternSensor* sensormsg);

  // optional int32 ctrl_device = 4;
  inline bool has_ctrl_device() const;
  inline void clear_ctrl_device();
  static const int kCtrlDeviceFieldNumber = 4;
  inline ::google::protobuf::int32 ctrl_device() const;
  inline void set_ctrl_device(::google::protobuf::int32 value);

  // optional .BmsMessage bmsMsg = 5;
  inline bool has_bmsmsg() const;
  inline void clear_bmsmsg();
  static const int kBmsMsgFieldNumber = 5;
  inline const ::BmsMessage& bmsmsg() const;
  inline ::BmsMessage* mutable_bmsmsg();
  inline ::BmsMessage* release_bmsmsg();
  inline void set_allocated_bmsmsg(::BmsMessage* bmsmsg);

  // optional .ErrorMessage errormsg = 6;
  inline bool has_errormsg() const;
  inline void clear_errormsg();
  static const int kErrormsgFieldNumber = 6;
  inline const ::ErrorMessage& errormsg() const;
  inline ::ErrorMessage* mutable_errormsg();
  inline ::ErrorMessage* release_errormsg();
  inline void set_allocated_errormsg(::ErrorMessage* errormsg);

  // optional .AlarmMessage alarmmsg = 7;
  inline bool has_alarmmsg() const;
  inline void clear_alarmmsg();
  static const int kAlarmmsgFieldNumber = 7;
  inline const ::AlarmMessage& alarmmsg() const;
  inline ::AlarmMessage* mutable_alarmmsg();
  inline ::AlarmMessage* release_alarmmsg();
  inline void set_allocated_alarmmsg(::AlarmMessage* alarmmsg);

  // optional .UltrasoundMessage Ultrasound = 8;
  inline bool has_ultrasound() const;
  inline void clear_ultrasound();
  static const int kUltrasoundFieldNumber = 8;
  inline const ::UltrasoundMessage& ultrasound() const;
  inline ::UltrasoundMessage* mutable_ultrasound();
  inline ::UltrasoundMessage* release_ultrasound();
  inline void set_allocated_ultrasound(::UltrasoundMessage* ultrasound);

  // optional float LineVelocity = 9;
  inline bool has_linevelocity() const;
  inline void clear_linevelocity();
  static const int kLineVelocityFieldNumber = 9;
  inline float linevelocity() const;
  inline void set_linevelocity(float value);

  // optional float THVelocity = 10;
  inline bool has_thvelocity() const;
  inline void clear_thvelocity();
  static const int kTHVelocityFieldNumber = 10;
  inline float thvelocity() const;
  inline void set_thvelocity(float value);

  // optional .ph3airmsg ph3air = 11;
  inline bool has_ph3air() const;
  inline void clear_ph3air();
  static const int kPh3AirFieldNumber = 11;
  inline const ::ph3airmsg& ph3air() const;
  inline ::ph3airmsg* mutable_ph3air();
  inline ::ph3airmsg* release_ph3air();
  inline void set_allocated_ph3air(::ph3airmsg* ph3air);

  // @@protoc_insertion_point(class_scope:ControllerMessage)
 private:
  inline void set_has_stat();
  inline void clear_has_stat();
  inline void set_has_sensormsg();
  inline void clear_has_sensormsg();
  inline void set_has_ctrl_device();
  inline void clear_has_ctrl_device();
  inline void set_has_bmsmsg();
  inline void clear_has_bmsmsg();
  inline void set_has_errormsg();
  inline void clear_has_errormsg();
  inline void set_has_alarmmsg();
  inline void clear_has_alarmmsg();
  inline void set_has_ultrasound();
  inline void clear_has_ultrasound();
  inline void set_has_linevelocity();
  inline void clear_has_linevelocity();
  inline void set_has_thvelocity();
  inline void clear_has_thvelocity();
  inline void set_has_ph3air();
  inline void clear_has_ph3air();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::ControllerMessage_Dirver > dirvermessage_;
  ::google::protobuf::int32 stat_;
  ::google::protobuf::int32 ctrl_device_;
  ::ExternSensor* sensormsg_;
  ::BmsMessage* bmsmsg_;
  ::ErrorMessage* errormsg_;
  ::AlarmMessage* alarmmsg_;
  ::UltrasoundMessage* ultrasound_;
  float linevelocity_;
  float thvelocity_;
  ::ph3airmsg* ph3air_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_ControllerMessage_2eproto();
  friend void protobuf_AssignDesc_ControllerMessage_2eproto();
  friend void protobuf_ShutdownFile_ControllerMessage_2eproto();

  void InitAsDefaultInstance();
  static ControllerMessage* default_instance_;
};
// ===================================================================


// ===================================================================

// ControllerMessage_Dirver

// optional int32 device_status = 1;
inline bool ControllerMessage_Dirver::has_device_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerMessage_Dirver::set_has_device_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerMessage_Dirver::clear_has_device_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerMessage_Dirver::clear_device_status() {
  device_status_ = 0;
  clear_has_device_status();
}
inline ::google::protobuf::int32 ControllerMessage_Dirver::device_status() const {
  return device_status_;
}
inline void ControllerMessage_Dirver::set_device_status(::google::protobuf::int32 value) {
  set_has_device_status();
  device_status_ = value;
}

// optional int32 device_add = 2;
inline bool ControllerMessage_Dirver::has_device_add() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ControllerMessage_Dirver::set_has_device_add() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ControllerMessage_Dirver::clear_has_device_add() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ControllerMessage_Dirver::clear_device_add() {
  device_add_ = 0;
  clear_has_device_add();
}
inline ::google::protobuf::int32 ControllerMessage_Dirver::device_add() const {
  return device_add_;
}
inline void ControllerMessage_Dirver::set_device_add(::google::protobuf::int32 value) {
  set_has_device_add();
  device_add_ = value;
}

// optional int32 ActVelocity = 3;
inline bool ControllerMessage_Dirver::has_actvelocity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerMessage_Dirver::set_has_actvelocity() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerMessage_Dirver::clear_has_actvelocity() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerMessage_Dirver::clear_actvelocity() {
  actvelocity_ = 0;
  clear_has_actvelocity();
}
inline ::google::protobuf::int32 ControllerMessage_Dirver::actvelocity() const {
  return actvelocity_;
}
inline void ControllerMessage_Dirver::set_actvelocity(::google::protobuf::int32 value) {
  set_has_actvelocity();
  actvelocity_ = value;
}

// optional int32 SetVelocity = 4;
inline bool ControllerMessage_Dirver::has_setvelocity() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerMessage_Dirver::set_has_setvelocity() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerMessage_Dirver::clear_has_setvelocity() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerMessage_Dirver::clear_setvelocity() {
  setvelocity_ = 0;
  clear_has_setvelocity();
}
inline ::google::protobuf::int32 ControllerMessage_Dirver::setvelocity() const {
  return setvelocity_;
}
inline void ControllerMessage_Dirver::set_setvelocity(::google::protobuf::int32 value) {
  set_has_setvelocity();
  setvelocity_ = value;
}

// optional float ctrl_dc_Voltage = 5;
inline bool ControllerMessage_Dirver::has_ctrl_dc_voltage() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControllerMessage_Dirver::set_has_ctrl_dc_voltage() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControllerMessage_Dirver::clear_has_ctrl_dc_voltage() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControllerMessage_Dirver::clear_ctrl_dc_voltage() {
  ctrl_dc_voltage_ = 0;
  clear_has_ctrl_dc_voltage();
}
inline float ControllerMessage_Dirver::ctrl_dc_voltage() const {
  return ctrl_dc_voltage_;
}
inline void ControllerMessage_Dirver::set_ctrl_dc_voltage(float value) {
  set_has_ctrl_dc_voltage();
  ctrl_dc_voltage_ = value;
}

// optional float CTRL_IPM_TEMPERATURE = 6;
inline bool ControllerMessage_Dirver::has_ctrl_ipm_temperature() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ControllerMessage_Dirver::set_has_ctrl_ipm_temperature() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ControllerMessage_Dirver::clear_has_ctrl_ipm_temperature() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ControllerMessage_Dirver::clear_ctrl_ipm_temperature() {
  ctrl_ipm_temperature_ = 0;
  clear_has_ctrl_ipm_temperature();
}
inline float ControllerMessage_Dirver::ctrl_ipm_temperature() const {
  return ctrl_ipm_temperature_;
}
inline void ControllerMessage_Dirver::set_ctrl_ipm_temperature(float value) {
  set_has_ctrl_ipm_temperature();
  ctrl_ipm_temperature_ = value;
}

// optional int32 ActualPos = 7;
inline bool ControllerMessage_Dirver::has_actualpos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ControllerMessage_Dirver::set_has_actualpos() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ControllerMessage_Dirver::clear_has_actualpos() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ControllerMessage_Dirver::clear_actualpos() {
  actualpos_ = 0;
  clear_has_actualpos();
}
inline ::google::protobuf::int32 ControllerMessage_Dirver::actualpos() const {
  return actualpos_;
}
inline void ControllerMessage_Dirver::set_actualpos(::google::protobuf::int32 value) {
  set_has_actualpos();
  actualpos_ = value;
}

// optional bool EmergencyInputValue = 8;
inline bool ControllerMessage_Dirver::has_emergencyinputvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ControllerMessage_Dirver::set_has_emergencyinputvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ControllerMessage_Dirver::clear_has_emergencyinputvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ControllerMessage_Dirver::clear_emergencyinputvalue() {
  emergencyinputvalue_ = false;
  clear_has_emergencyinputvalue();
}
inline bool ControllerMessage_Dirver::emergencyinputvalue() const {
  return emergencyinputvalue_;
}
inline void ControllerMessage_Dirver::set_emergencyinputvalue(bool value) {
  set_has_emergencyinputvalue();
  emergencyinputvalue_ = value;
}

// optional string Error = 9;
inline bool ControllerMessage_Dirver::has_error() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ControllerMessage_Dirver::set_has_error() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ControllerMessage_Dirver::clear_has_error() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ControllerMessage_Dirver::clear_error() {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    error_->clear();
  }
  clear_has_error();
}
inline const ::std::string& ControllerMessage_Dirver::error() const {
  return *error_;
}
inline void ControllerMessage_Dirver::set_error(const ::std::string& value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void ControllerMessage_Dirver::set_error(const char* value) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(value);
}
inline void ControllerMessage_Dirver::set_error(const char* value, size_t size) {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  error_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ControllerMessage_Dirver::mutable_error() {
  set_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    error_ = new ::std::string;
  }
  return error_;
}
inline ::std::string* ControllerMessage_Dirver::release_error() {
  clear_has_error();
  if (error_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_;
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ControllerMessage_Dirver::set_allocated_error(::std::string* error) {
  if (error_ != &::google::protobuf::internal::kEmptyString) {
    delete error_;
  }
  if (error) {
    set_has_error();
    error_ = error;
  } else {
    clear_has_error();
    error_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .MotecDriverStat motec = 10;
inline bool ControllerMessage_Dirver::has_motec() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ControllerMessage_Dirver::set_has_motec() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ControllerMessage_Dirver::clear_has_motec() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ControllerMessage_Dirver::clear_motec() {
  if (motec_ != NULL) motec_->::MotecDriverStat::Clear();
  clear_has_motec();
}
inline const ::MotecDriverStat& ControllerMessage_Dirver::motec() const {
  return motec_ != NULL ? *motec_ : *default_instance_->motec_;
}
inline ::MotecDriverStat* ControllerMessage_Dirver::mutable_motec() {
  set_has_motec();
  if (motec_ == NULL) motec_ = new ::MotecDriverStat;
  return motec_;
}
inline ::MotecDriverStat* ControllerMessage_Dirver::release_motec() {
  clear_has_motec();
  ::MotecDriverStat* temp = motec_;
  motec_ = NULL;
  return temp;
}
inline void ControllerMessage_Dirver::set_allocated_motec(::MotecDriverStat* motec) {
  delete motec_;
  motec_ = motec;
  if (motec) {
    set_has_motec();
  } else {
    clear_has_motec();
  }
}

// optional float ActCurrent = 11;
inline bool ControllerMessage_Dirver::has_actcurrent() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ControllerMessage_Dirver::set_has_actcurrent() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ControllerMessage_Dirver::clear_has_actcurrent() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ControllerMessage_Dirver::clear_actcurrent() {
  actcurrent_ = 0;
  clear_has_actcurrent();
}
inline float ControllerMessage_Dirver::actcurrent() const {
  return actcurrent_;
}
inline void ControllerMessage_Dirver::set_actcurrent(float value) {
  set_has_actcurrent();
  actcurrent_ = value;
}

// -------------------------------------------------------------------

// ControllerMessage

// optional int32 Stat = 1;
inline bool ControllerMessage::has_stat() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ControllerMessage::set_has_stat() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ControllerMessage::clear_has_stat() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ControllerMessage::clear_stat() {
  stat_ = 0;
  clear_has_stat();
}
inline ::google::protobuf::int32 ControllerMessage::stat() const {
  return stat_;
}
inline void ControllerMessage::set_stat(::google::protobuf::int32 value) {
  set_has_stat();
  stat_ = value;
}

// repeated .ControllerMessage.Dirver DirverMessage = 2;
inline int ControllerMessage::dirvermessage_size() const {
  return dirvermessage_.size();
}
inline void ControllerMessage::clear_dirvermessage() {
  dirvermessage_.Clear();
}
inline const ::ControllerMessage_Dirver& ControllerMessage::dirvermessage(int index) const {
  return dirvermessage_.Get(index);
}
inline ::ControllerMessage_Dirver* ControllerMessage::mutable_dirvermessage(int index) {
  return dirvermessage_.Mutable(index);
}
inline ::ControllerMessage_Dirver* ControllerMessage::add_dirvermessage() {
  return dirvermessage_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ControllerMessage_Dirver >&
ControllerMessage::dirvermessage() const {
  return dirvermessage_;
}
inline ::google::protobuf::RepeatedPtrField< ::ControllerMessage_Dirver >*
ControllerMessage::mutable_dirvermessage() {
  return &dirvermessage_;
}

// optional .ExternSensor SensorMsg = 3;
inline bool ControllerMessage::has_sensormsg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ControllerMessage::set_has_sensormsg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ControllerMessage::clear_has_sensormsg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ControllerMessage::clear_sensormsg() {
  if (sensormsg_ != NULL) sensormsg_->::ExternSensor::Clear();
  clear_has_sensormsg();
}
inline const ::ExternSensor& ControllerMessage::sensormsg() const {
  return sensormsg_ != NULL ? *sensormsg_ : *default_instance_->sensormsg_;
}
inline ::ExternSensor* ControllerMessage::mutable_sensormsg() {
  set_has_sensormsg();
  if (sensormsg_ == NULL) sensormsg_ = new ::ExternSensor;
  return sensormsg_;
}
inline ::ExternSensor* ControllerMessage::release_sensormsg() {
  clear_has_sensormsg();
  ::ExternSensor* temp = sensormsg_;
  sensormsg_ = NULL;
  return temp;
}
inline void ControllerMessage::set_allocated_sensormsg(::ExternSensor* sensormsg) {
  delete sensormsg_;
  sensormsg_ = sensormsg;
  if (sensormsg) {
    set_has_sensormsg();
  } else {
    clear_has_sensormsg();
  }
}

// optional int32 ctrl_device = 4;
inline bool ControllerMessage::has_ctrl_device() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ControllerMessage::set_has_ctrl_device() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ControllerMessage::clear_has_ctrl_device() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ControllerMessage::clear_ctrl_device() {
  ctrl_device_ = 0;
  clear_has_ctrl_device();
}
inline ::google::protobuf::int32 ControllerMessage::ctrl_device() const {
  return ctrl_device_;
}
inline void ControllerMessage::set_ctrl_device(::google::protobuf::int32 value) {
  set_has_ctrl_device();
  ctrl_device_ = value;
}

// optional .BmsMessage bmsMsg = 5;
inline bool ControllerMessage::has_bmsmsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ControllerMessage::set_has_bmsmsg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ControllerMessage::clear_has_bmsmsg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ControllerMessage::clear_bmsmsg() {
  if (bmsmsg_ != NULL) bmsmsg_->::BmsMessage::Clear();
  clear_has_bmsmsg();
}
inline const ::BmsMessage& ControllerMessage::bmsmsg() const {
  return bmsmsg_ != NULL ? *bmsmsg_ : *default_instance_->bmsmsg_;
}
inline ::BmsMessage* ControllerMessage::mutable_bmsmsg() {
  set_has_bmsmsg();
  if (bmsmsg_ == NULL) bmsmsg_ = new ::BmsMessage;
  return bmsmsg_;
}
inline ::BmsMessage* ControllerMessage::release_bmsmsg() {
  clear_has_bmsmsg();
  ::BmsMessage* temp = bmsmsg_;
  bmsmsg_ = NULL;
  return temp;
}
inline void ControllerMessage::set_allocated_bmsmsg(::BmsMessage* bmsmsg) {
  delete bmsmsg_;
  bmsmsg_ = bmsmsg;
  if (bmsmsg) {
    set_has_bmsmsg();
  } else {
    clear_has_bmsmsg();
  }
}

// optional .ErrorMessage errormsg = 6;
inline bool ControllerMessage::has_errormsg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ControllerMessage::set_has_errormsg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ControllerMessage::clear_has_errormsg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ControllerMessage::clear_errormsg() {
  if (errormsg_ != NULL) errormsg_->::ErrorMessage::Clear();
  clear_has_errormsg();
}
inline const ::ErrorMessage& ControllerMessage::errormsg() const {
  return errormsg_ != NULL ? *errormsg_ : *default_instance_->errormsg_;
}
inline ::ErrorMessage* ControllerMessage::mutable_errormsg() {
  set_has_errormsg();
  if (errormsg_ == NULL) errormsg_ = new ::ErrorMessage;
  return errormsg_;
}
inline ::ErrorMessage* ControllerMessage::release_errormsg() {
  clear_has_errormsg();
  ::ErrorMessage* temp = errormsg_;
  errormsg_ = NULL;
  return temp;
}
inline void ControllerMessage::set_allocated_errormsg(::ErrorMessage* errormsg) {
  delete errormsg_;
  errormsg_ = errormsg;
  if (errormsg) {
    set_has_errormsg();
  } else {
    clear_has_errormsg();
  }
}

// optional .AlarmMessage alarmmsg = 7;
inline bool ControllerMessage::has_alarmmsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ControllerMessage::set_has_alarmmsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ControllerMessage::clear_has_alarmmsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ControllerMessage::clear_alarmmsg() {
  if (alarmmsg_ != NULL) alarmmsg_->::AlarmMessage::Clear();
  clear_has_alarmmsg();
}
inline const ::AlarmMessage& ControllerMessage::alarmmsg() const {
  return alarmmsg_ != NULL ? *alarmmsg_ : *default_instance_->alarmmsg_;
}
inline ::AlarmMessage* ControllerMessage::mutable_alarmmsg() {
  set_has_alarmmsg();
  if (alarmmsg_ == NULL) alarmmsg_ = new ::AlarmMessage;
  return alarmmsg_;
}
inline ::AlarmMessage* ControllerMessage::release_alarmmsg() {
  clear_has_alarmmsg();
  ::AlarmMessage* temp = alarmmsg_;
  alarmmsg_ = NULL;
  return temp;
}
inline void ControllerMessage::set_allocated_alarmmsg(::AlarmMessage* alarmmsg) {
  delete alarmmsg_;
  alarmmsg_ = alarmmsg;
  if (alarmmsg) {
    set_has_alarmmsg();
  } else {
    clear_has_alarmmsg();
  }
}

// optional .UltrasoundMessage Ultrasound = 8;
inline bool ControllerMessage::has_ultrasound() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ControllerMessage::set_has_ultrasound() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ControllerMessage::clear_has_ultrasound() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ControllerMessage::clear_ultrasound() {
  if (ultrasound_ != NULL) ultrasound_->::UltrasoundMessage::Clear();
  clear_has_ultrasound();
}
inline const ::UltrasoundMessage& ControllerMessage::ultrasound() const {
  return ultrasound_ != NULL ? *ultrasound_ : *default_instance_->ultrasound_;
}
inline ::UltrasoundMessage* ControllerMessage::mutable_ultrasound() {
  set_has_ultrasound();
  if (ultrasound_ == NULL) ultrasound_ = new ::UltrasoundMessage;
  return ultrasound_;
}
inline ::UltrasoundMessage* ControllerMessage::release_ultrasound() {
  clear_has_ultrasound();
  ::UltrasoundMessage* temp = ultrasound_;
  ultrasound_ = NULL;
  return temp;
}
inline void ControllerMessage::set_allocated_ultrasound(::UltrasoundMessage* ultrasound) {
  delete ultrasound_;
  ultrasound_ = ultrasound;
  if (ultrasound) {
    set_has_ultrasound();
  } else {
    clear_has_ultrasound();
  }
}

// optional float LineVelocity = 9;
inline bool ControllerMessage::has_linevelocity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ControllerMessage::set_has_linevelocity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ControllerMessage::clear_has_linevelocity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ControllerMessage::clear_linevelocity() {
  linevelocity_ = 0;
  clear_has_linevelocity();
}
inline float ControllerMessage::linevelocity() const {
  return linevelocity_;
}
inline void ControllerMessage::set_linevelocity(float value) {
  set_has_linevelocity();
  linevelocity_ = value;
}

// optional float THVelocity = 10;
inline bool ControllerMessage::has_thvelocity() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ControllerMessage::set_has_thvelocity() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ControllerMessage::clear_has_thvelocity() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ControllerMessage::clear_thvelocity() {
  thvelocity_ = 0;
  clear_has_thvelocity();
}
inline float ControllerMessage::thvelocity() const {
  return thvelocity_;
}
inline void ControllerMessage::set_thvelocity(float value) {
  set_has_thvelocity();
  thvelocity_ = value;
}

// optional .ph3airmsg ph3air = 11;
inline bool ControllerMessage::has_ph3air() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ControllerMessage::set_has_ph3air() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ControllerMessage::clear_has_ph3air() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ControllerMessage::clear_ph3air() {
  if (ph3air_ != NULL) ph3air_->::ph3airmsg::Clear();
  clear_has_ph3air();
}
inline const ::ph3airmsg& ControllerMessage::ph3air() const {
  return ph3air_ != NULL ? *ph3air_ : *default_instance_->ph3air_;
}
inline ::ph3airmsg* ControllerMessage::mutable_ph3air() {
  set_has_ph3air();
  if (ph3air_ == NULL) ph3air_ = new ::ph3airmsg;
  return ph3air_;
}
inline ::ph3airmsg* ControllerMessage::release_ph3air() {
  clear_has_ph3air();
  ::ph3airmsg* temp = ph3air_;
  ph3air_ = NULL;
  return temp;
}
inline void ControllerMessage::set_allocated_ph3air(::ph3airmsg* ph3air) {
  delete ph3air_;
  ph3air_ = ph3air;
  if (ph3air) {
    set_has_ph3air();
  } else {
    clear_has_ph3air();
  }
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ControllerMessage_2eproto__INCLUDED
